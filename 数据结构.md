# 二分查找

```java
public int search(int nums[],int target){
    int left = 0 ;
    int right = nums.length-1;
    int mid;
    while(left<=right){
        mid = left + ((right-left)>>1);//直接(left+right)/2可能会溢出
        if(target == nums[mid]){
            return mid;
        }
        else if (target<nums[mid]){
            right = mid-1;
        }
        else if (target>nums[mid]){
            left = mid+1;
        }
    }
    return -1;
}
```

# 排序算法

![image-20221225133208951](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20221225133208951.png)

稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面

不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。

## 冒泡排序

```java
public static void BubbleSort(int nums[]){//从小到大排序
    for(int i = 0;i<nums.length-1;i++){//总共进行num.length-1轮冒泡
        for(int j = 0;j<nums.length-1-i;j++){//两两比对次数为nums.length-1-i
            if(nums[j]>nums[j+1]){
                int temp = nums[j+1];
                nums[j+1] = nums[j];
                nums[j] = temp;
            }
        }
    }
}
```

## 快速排序

​	快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。

```java
public static void QuickSort(int[]nums,int low,int high){
    if(low>high) return;
    int base,i,j,temp;
    i=low;
    j=high;
    base = nums[low];
    while(i<j){
        while(nums[j]>=base&&i<j){
            j--;
        }
        while(nums[i]<=base&&i<j){
            i++;
        }
        if(i<j){
            temp=nums[i];
            nums[i]=nums[j];
            nums[j]=temp;
        }
    }
    nums[low]=nums[i];
    nums[i]=base;
    QuickSort(nums,low,j-1);
    QuickSort(nums,j+1,high);
}
public static void main(String[] args){
        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};
        quickSort(arr, 0, arr.length-1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
}

```



## 归并排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/43eb7536911b40ce9a967df98588d6b7.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/f34202b91b12436986889e8d9cd9273e.png)

```java
public static void mergeSort(int []nums,int left,int right,int []temp){
    if(left==right) return;
    int mid = left+((right-left)>>1);
    mergeSort(nums,left,mid,temp);
    mergeSort(nums,mid+1,right,temp);
	 for(int i=left;i<=right;i++){
         temp[i]=nums[i];
     }
    int i = left;
    int j = mid+1;
    int k =left;
    while(i<=mid&&j<=right){
        if(temp[i]<=temp[j]){
            nums[k++]=temp[i++];
        }
        else {
            nums[k++]=temp[j++];
        }
    }
    while(i<=mid) nums[k++]=temp[i++];
    while(j<=right) nums[k++]=temp[j++];
    
}
```

## 堆排序

```java

```

BFS和DFS的适用场景

遍历中递归实现和非递归实现的区别

数据非常大无法放入内存如何做？还有别的方案么？这个方案有哪些不足？

零拷贝知道么

100万条客户id记录，丢失了,两条，如何把丢失的数据查找出来

图怎么存的、有哪些图算法

红黑树怎么实现、如果树里面有两个值相等的节点，怎么识别？

程序是如何跑起来的
大致就是在问：一个程序，由代码组成，代码一般都是高级语言编写，计算机并不能直接运行，需要翻译成机器能够识别的比方说汇编指令，通过一连串汇编的指令完成程序需要完成的功能。

队列的poll和remove的区别

算法：

1. 两个整数相除，用字符串返回其结果，如果存在循环节，用括号表示。eg 1/3; 结果"0.(3)"  eg: "0.187(43)"

​	提示说用辗转相除，然而楼主太菜最后还是没有完全写出来。。。。

2. 编程题判断括号是否匹配，如"{[]()]}"

3. 你了解查找树吗，手撕代码，如何判断一个树是否符合查找树的规则

4. 编程说思路：1G文件，每行是一个词，内存1M，求词频最大的前100个词

5. 编程：求前K大的数 (我问能import heapq吗，面试官说算了你说下思路就行……)

6. 编程：m*n的矩阵，初始位置(x, y)，只能用中国象棋马的走法，走过的位置不能再走，能否遍历矩阵

7. 编程：输入二叉树，输出平衡二叉树

8. 编程：手撕线程池(开始自闭，没接触过)

9. 第一题是找有多少个倒叙数列；

10. 第二题是让写计算一个最长序列的树的长度；写完还会问怎么优化之类的...

11. 来了道算法题，两个三十六进制字符串的相加

12. 100亿个数怎么求中位数

13. 数组求top k

14. 从第k个元素开始翻转链表

15. 二叉树按层输出

16. 一个数组输出全排列个数 --> 具体排列都有什么(位运算）

17. 二叉树最大路径和

18. 编程题：二叉树层序遍历，按层换行输出。

19. 场景设计题：你自己如何设计一个分布式系统，实现对百亿条数据进行分组并求和

20. 编程题：一个数组有正数有负数，调整数组中的数使得正负交替

    例：[-3, 6, 7, -4] ->[6, -3, 7, -4]

21. ![img](https://uploadfiles.nowcoder.com/images/20200417/4958476_1587122591927_ACED241801E307EE7A39612F85A94EBF)

22. 手撕代码 最长无重复元素的子序列

23. 一百万个数 有重复元素 求中位数

24. 算法题：实现左旋n位的字符数组？

25. 算法，扔鸡蛋问题

26. 算法，字符串S1的全排列是否为S2的字串'

27. 手写斐波那契数列（递归和非递归）？

28. 手写代码：大数相乘？

29. 合并可能有重叠部分的集合

30. 编程题：使用文件IO读取文件数据，读取每一行数据，将每行数据以分好分割，提取每个单词并统计每个单词的重复数然后进行排序

```java
public class HuaweiYiMian {
	//使用文件IO读取文件数据，因为是单词，所以使用字符流
	public static void main(String[]agrs) {
		InputStreamReader isr = null;
		File file = new File("E:\\test.txt");
		BufferedReader br = null;
        //使用TreeMap只能进行key值的排序。。。
		Map<String,Integer> map = new TreeMap<>(); 
		try {
			isr = new InputStreamReader(new FileInputStream(file),"gbk");
			br = new BufferedReader(isr);
			String line = "";
			while((line = br.readLine())!=null) {
				String[]strs = line.split(";");
				for(int i = 0;i<strs.length;i++) {
					if(map.get(strs[i]) != null) {
						map.put(strs[i], map.get(strs[i])+1);
					}else {
						map.put(strs[i],1);
					}
				}
			}
		}catch(FileNotFoundException e) {
			e.printStackTrace();
		}catch(IOException e) {
			e.printStackTrace();
		}finally {
			try {
				isr.close();
			}catch(IOException e) {
				e.printStackTrace();
			}
			
		}
         //为了实现value值的排序，要将treeMap中元素的entrySet放进一个List集合中，再使用				//Collections工具类实现排序
		ArrayList<Entry<String,Integer>>list = new ArrayList<>(map.entrySet());
		Collections.sort(list,new Comparator<Entry<String,Integer>>() {
			public int compare(Entry<String,Integer> o1,Entry<String,Integer> o2){
				return o2.getValue()-o1.getValue(); 
			}
		});
		for(Entry<String,Integer> e:list) {
			System.out.println(e.getKey()+" "+e.getValue());
		}
	}
}
```

31. 编程题：判断一个数是否为完全平方数，不能使用库函数sqrt()，尽量降低时间复杂度。

```
public class HuaweiErMian {
	public static void getRs(int num){
		int len = num;
		//使用二分查找
		boolean rs = Helper(num);
		System.out.println(rs);
	}
	public static boolean Helper(int key){
		int mid;
		int start = 1;
		int end = key/2;
		while(start<=end){
			mid = start+(end-start)/2;
			if(key>mid*mid){
				start=mid+1;
			}else if(key<mid*mid){
				end = mid-1;
			}else{
				return true;
			}
		}
		return false;
	}
	
}
```

32. 写了个字符串排序比如 dDacAs ,排序成AacDds，分大小写排序，本来要写一个统计代码行数（去掉注释）
33. 手写二叉树镜像
34. 编程题，口述思想：给定一个字符串“112233...”，如何输出“11:22:33:..”？除了暴力法，你还能想到用什么方法？
35. 最长公共子序列(LCS)问题. 动态规划
36. 找出二叉树中任意两个节点的最低公共根节点, 如果树是BST呢. 深度优先搜索+二分查找树性质
37. 100亿个数字，找出其中不重复的数字(说想法)
37. 怎么确定数组是否有重复数据
37. 情景题：滑动窗口输出窗口中的最大值
37. 编程：三个线程轮流输出1-100
37. 写生成随机数并去重的代码
37. ![img](https://uploadfiles.nowcoder.com/images/20200327/4958476_1585299489803_C0DB79F7FEDCABDFC0508E1D0A3FE14F)

random()随机产生[0, 正无穷)范围的随机数，利用该方法产生生成[m,n]范围的随机数。

43. 堆是什么？大顶堆和小顶堆是什么？假如现在有一个堆，大顶堆和小顶堆，如果要把大顶堆转换成小顶堆，怎么做？如果要遍历一个大顶堆，一般有什么办法？

43. 代码:n的全排列

43. 代码题:spark rdd,一个rdd中有很多的（k,v）使用groupByKey和reduceByKey如何得到（k,iterable[v]）,代码详细写出来

43. 算法题 查找数组的中位数 O（n）

43. 最长公共子串

43. 写一个算法判断一个图是不是DAG

43. 如何求一个二叉树的高度？简要说明方法。（答递归），非递归呢？

43. 算法题：有一个int数组{1,-5,6,5,0,2,-1,9,6,7}，用最优的时间和空间复杂度，得到一个二元组a+b=0。求所有这样的a、b数据对。

    ①先用了HashMap实现。问时间复杂度？

    ②如果不允许使用工具类呢？考察底层的算法知识。扯了下先排序，然后双指针，问时间复杂度？问面试官得知数据有可能存在重复。然后让写双指针遍历的过程。说一下思路吧？

43. 找出字符串中第一个只出现一次的字符

43. 重复删除当前指针后面的第n个数

43. 数组找到所有重复元素

43. 堆kv数据，如何保证整理后的kv首尾相连，比如(1,2)->(3,4)->(2,3)----->(1,2)->(2,3)->(3,4)

43. 判断单链表是否是回文

43. 数组最大子串累加和，动态规划经典题目，然后实现其分布式算法，假设这个数组被存储在不同的partition中，partition中数据以partitionid实现排序，通过rdd分布式实现这个算法

43. 第一题：从一个rdd中过滤出另一个rdd的数据

43. 第二题：求一个数组中累加和在一个区间的种数

43. 逆时针打印矩阵

43. count and say

43. 一个字符串如何删除不匹配的括号然后输出括号匹配的字符串

43. 判断有向图中是否有环

43. ```
    【筛选帖子】
    给定一批帖子记录，记录内容包括帖子ID、评论等等完整信息，查找只被评论过奇数次的帖子。假设奇数次帖子只有一个。
    ```

64. list如何求中位数？提示两个堆

65. 手撕最大连续子数组和。

66. 手撕两个排序链表合并

67. 手撕判断二叉树是否对称

68. 手撕链表反转，二叉树高度

69. 给你出个算法吧 给你一个字符串ip地址  需要把他转换成int类型  然后要再能转回来

70. 求两个字符串的公共子串最大长度

71. 算法题：二维矩阵相乘

72. 被围绕的区域，leetcode第130题原题

73. 两道算法题：路径问题，leetcode上63题和64题原题

74. 算法题：使用最小花费爬楼梯

75. 两个有序数组找出其合并排序后的中位数

76. 在一个整数数组中，找出出现次数大于一半的数。使用空间复杂度为O（1）的算法

77. 代码实现循环数组

78. 有一个很长的数组，如何使用更高效的方式来检测只出现一次的元素

79. 找出一个整数数组中出现次数最多的数

80. 判断一个字符串是不是两个有序的字符串交错组成的

81. 有10G的数据，2G内存，取中位数

82. 给你一个字符串（可能很长），字符串包含数字和字母，要求将字符串里的字母反转，但数字不动

68. 一个整型数组a，一个数key，求数组a中所有相加等于key的子数组。（注：注意子集概念。可能有负数。）
