

## zset数据结构

* 使用压缩列表（ziplist）：当 `ZSET` 中的元素数量较少（默认小于 128 个元素）且每个元素的值较小（默认小于 64 字节）时，Redis 会使用压缩列表来存储 `ZSET`。`Ziplist` 是一种紧凑的双向链表，节省内存，但插入和删除操作的性能相对较低。`Ziplist` 通过压缩元素间的空间实现更高的内存利用率，适合小数据量的场景

* 使用跳跃表(skiplist)：当 Zset 存储的元素数量超过 zset-max-ziplist-entries 的值，或者任何元素的长度超过 zset-max-ziplist-value 的值时，Redis 会将底层结构从压缩列表转换为跳跃表。跳跃表的查找和修改数据的性能较高，但是占用的内存也较多。

![image-20241026213208151](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20241026213208151.png)

## redis setnx相关

1. 定义

`SETNX` 是 Redis 提供的一个用于实现分布式锁的原子操作。`SETNX` 的全称是 “Set if Not exists”，它的作用是 **只有在键不存在时才设置键的值**。这使得 `SETNX` 非常适合实现分布式锁或确保某个资源的互斥访问。

`SETNX` 的操作具有原子性，即它会确保“检查键是否存在”和“设置键的值”这两个操作是不可分割的，这在并发环境下非常重要。

```
SETNX key value
如果键不存在，则 SETNX 会设置成功，返回 1。
如果键已经存在，则 SETNX 不会设置新值，返回 0。
```

2. 使用 `SETNX` 实现分布式锁

`SETNX` 可以用来实现分布式锁，确保多个进程不会同时访问共享资源。这里是一个简单的分布式锁实现逻辑：

1. **尝试加锁**：使用 `SETNX key value`，只有当锁不存在时才能成功设置（即加锁成功），否则返回失败。
2. **设置过期时间**：为了防止死锁（加锁的进程异常退出后无法释放锁），可以通过 `EXPIRE key timeout` 设置锁的过期时间，确保锁在超时后自动释放。
3. **释放锁**：当任务完成时，主动删除该键来释放锁。

```
-- 加锁
SETNX lock_key my_value

-- 设置过期时间（避免死锁）
EXPIRE lock_key 10  -- 锁的有效期为10秒

```

> **原子性问题**：`SETNX` 和 `EXPIRE` 是两个命令，之间不是原子的。在 Redis 2.6.12 及以上版本，可以使用带 `PX` 参数的 `SET` 命令实现相同的功能：SET lock_key my_value NX PX 10000



## Redis 常用指令

1. 通用命令

| 指令           | 说明                                           |
| -------------- | ---------------------------------------------- |
| `PING`         | 测试连接，返回 `PONG`                          |
| `SELECT`       | 切换数据库，默认有 16 个数据库，编号从 0 到 15 |
| `DBSIZE`       | 返回当前数据库中的键的数量                     |
| `KEYS pattern` | 返回匹配指定模式的所有键（如 `KEYS *`）        |
| `EXPIRE`       | 设置键的过期时间（秒）                         |
| `TTL`          | 查看键的剩余生存时间（秒）                     |
| `DEL`          | 删除指定键                                     |
| `FLUSHDB`      | 清空当前数据库                                 |
| `FLUSHALL`     | 清空所有数据库                                 |



2. 字符串操作（String）

**字符串**是 Redis 中最基本、最常用的数据类型，可以存储 **字符串、整数、浮点数** 等值。每个键最多可以存储 512 MB 的数据

```
SET name "Alice"         # 设置字符串
GET name                 # 获取字符串
INCR counter             # 自增
APPEND name " Johnson"   # 拼接字符串，结果为 "Alice Johnson"

```

| 指令                      | 说明                           |
| ------------------------- | ------------------------------ |
| `SET key value`           | 设置键的值                     |
| `GET key`                 | 获取键的值                     |
| `INCR key`                | 将键的整数值加 1               |
| `DECR key`                | 将键的整数值减 1               |
| `APPEND key value`        | 将字符串追加到键的原值后       |
| `MSET key value ...`      | 设置多个键值对                 |
| `MGET key ...`            | 获取多个键的值                 |
| `GETSET key value`        | 设置键的新值，并返回旧值       |
| `SETNX key value`         | 仅当键不存在时，设置键的值     |
| `SETEX key seconds value` | 设置键的值并设置过期时间（秒） |

3. 哈希操作（Hash）

**哈希**是一种键值对集合，适合存储对象或结构化的数据。每个哈希表可以包含多个字段和值（类似于对象或字典）

```
HSET user:1001 name "Alice"       # 设置哈希字段
HSET user:1001 age 30
HGET user:1001 name               # 获取字段
HGETALL user:1001                 # 获取所有字段和值
HDEL user:1001 age                # 删除字段

```

| 指令                          | 说明                     |
| ----------------------------- | ------------------------ |
| `HSET key field value`        | 设置哈希表字段的值       |
| `HGET key field`              | 获取哈希表字段的值       |
| `HMSET key field value ...`   | 设置多个字段及值         |
| `HMGET key field ...`         | 获取多个字段的值         |
| `HGETALL key`                 | 获取哈希表中所有字段和值 |
| `HDEL key field ...`          | 删除一个或多个字段       |
| `HLEN key`                    | 获取哈希表的字段数量     |
| `HEXISTS key field`           | 检查字段是否存在         |
| `HINCRBY key field increment` | 增加字段的整数值         |



4. 列表操作（List）

**列表**是一个双向链表，可以从左或右插入、弹出元素。它适合实现队列、栈等数据结构

```
LPUSH tasks "task1"               # 从左侧插入元素
RPUSH tasks "task2"               # 从右侧插入元素
LPOP tasks                        # 从左侧弹出，返回 "task1"
RPOP tasks                        # 从右侧弹出，返回 "task2"
LRANGE tasks 0 -1                 # 获取列表中所有元素
```



| 指令                    | 说明                                 |
| ----------------------- | ------------------------------------ |
| `LPUSH key value ...`   | 从左侧插入一个或多个值               |
| `RPUSH key value ...`   | 从右侧插入一个或多个值               |
| `LPOP key`              | 从左侧弹出元素                       |
| `RPOP key`              | 从右侧弹出元素                       |
| `LRANGE key start stop` | 获取指定范围内的元素                 |
| `LLEN key`              | 获取列表长度                         |
| `LINDEX key index`      | 获取指定索引的元素                   |
| `LSET key index value`  | 设置指定索引的值                     |
| `LTRIM key start stop`  | 对列表进行修剪，保留指定范围内的元素 |



5. 集合操作（Set）

**集合**是一个无序集合，元素不重复，适合用于存储一些不需要顺序、且不重复的数据

```
SADD fruits "apple"              # 添加元素到集合
SADD fruits "banana"
SADD fruits "apple"              # 重复元素不会被添加
SMEMBERS fruits                  # 获取所有集合元素
SISMEMBER fruits "banana"        # 检查元素是否在集合中，返回 1 表示存在
SREM fruits "apple"              # 从集合中移除元素
```



| 指令                   | 说明                     |
| ---------------------- | ------------------------ |
| `SADD key member ...`  | 添加一个或多个元素到集合 |
| `SREM key member ...`  | 移除一个或多个元素       |
| `SMEMBERS key`         | 获取集合中的所有元素     |
| `SISMEMBER key member` | 检查元素是否在集合中     |
| `SCARD key`            | 获取集合的元素个数       |
| `SDIFF key ...`        | 获取多个集合的差集       |
| `SINTER key ...`       | 获取多个集合的交集       |
| `SUNION key ...`       | 获取多个集合的并集       |



6. 有序集合操作（Sorted Set）

**有序集合**类似于集合，不同的是每个元素关联一个分数，集合根据分数进行排序。适合用于排行榜、按分数排序的数据等场景

```
ZADD leaderboard 100 "Alice"     # 添加元素及其分数
ZADD leaderboard 200 "Bob"
ZRANGE leaderboard 0 -1          # 按分数升序获取所有元素
ZRANGE leaderboard 0 -1 WITHSCORES  # 获取元素及其分数
ZREVRANGE leaderboard 0 -1       # 按分数降序获取所有元素
ZRANGEBYSCORE leaderboard 150 250  # 获取分数在150到250之间的元素
```



| 指令                                    | 说明                     |
| --------------------------------------- | ------------------------ |
| `ZADD key score member ...`             | 添加元素及其分数         |
| `ZREM key member ...`                   | 移除一个或多个元素       |
| `ZRANGE key start stop [WITHSCORES]`    | 按索引范围升序获取元素   |
| `ZREVRANGE key start stop [WITHSCORES]` | 按索引范围降序获取元素   |
| `ZRANGEBYSCORE key min max`             | 获取指定分数范围内的元素 |
| `ZCARD key`                             | 获取集合的成员个数       |
| `ZSCORE key member`                     | 获取指定成员的分数       |
| `ZINCRBY key increment member`          | 增加指定成员的分数       |



## Redis哪些地方使用了多线程

1. redis4.0针对部分场景使用多线程，eg:

`UNLINK`：可以看作是 `DEL` 命令的异步版本。

`FLUSHALL ASYNC`：用于清空所有数据库的所有键，不限于当前 `SELECT` 的数据库。

`FLUSHDB ASYNC`：用于清空当前 `SELECT` 数据库中的所有键

2. Redis 6.0 在网络模型中正式引入了多线程

​	Redis 6.0 的多线程模型仅将网络 I/O 的读写任务分给多线程来完成，以加速网络数据传输。在这个模型下，Redis 的大部分逻辑仍然保持和单线程一致，变动的地方主要是**客户端请求的读取和响应的回写**。具体来说：

① **I/O 线程**的职责是异步读取客户端请求数据并将响应数据写回到客户端，解决网络传输的瓶颈。

② **I/O 线程不会执行命令**：读取完数据后，命令的实际解析和执行仍然在单线程中完成，以保证数据一致性和减少锁管理的复杂性。

​	这种设计带来的好处是，**Redis 的核心逻辑依然保持单线程模型的简单和高效性**，同时可以利用多线程来提升高并发场景下的网络 I/O 性能





## 高并发点赞设计

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/895a1a219c67abdec0079d403917daea.png)

1. **用户点赞请求**：用户发起点赞请求，负载均衡器（如 Nginx）会将点赞请求分配到后端的不同服务器实例上，避免某一台服务器压力过大

2. **布隆过滤器去重**：利用布隆过滤器快速判断用户是否已点赞，避免重复操作。

3. **消息队列异步处理**：有效的点赞请求进入消息队列（如 Kafka、RabbitMQ）进行异步处理，防止直接写入数据库造成压力。

4. **缓存更新**：队列中的点赞操作更新 Redis 缓存中的计数，提供高效的点赞计数查询。

   * **Set**：适合需要追踪每个用户的点赞记录，适用于需要查询用户是否已点赞的应用(点赞去重)。

   ```redis
   # Set 示例：为文章ID 123 存储点赞的用户ID
   SADD post:123:likes user_1    # 用户 user_1 对文章 123 点赞
   SADD post:123:likes user_2    # 用户 user_2 对文章 123 点赞
   
   # 检查用户是否已点赞
   SISMEMBER post:123:likes user_1    # 返回 1 表示 user_1 已点赞，0 表示未点赞
   
   # 获取点赞总数
   SCARD post:123:likes    # 返回集合的大小，即点赞总数
   
   ```

   

   * **HashMap**：适合存储多个内容的点赞计数，适合场景中只需要快速获取点赞总数。

   ```redis
   # HashMap 示例：为每个内容记录点赞计数
   HINCRBY post_likes 123 1    # 文章ID 123 的点赞数加 1
   HINCRBY post_likes 456 1    # 文章ID 456 的点赞数加 1
   
   # 查询某个文章的点赞数
   HGET post_likes 123    # 返回 123 的点赞数
   
   # 获取所有点赞计数
   HGETALL post_likes     # 返回所有内容的点赞计数
   
   ```

   

   * **Bitmap**：适合大规模用户点赞的情况，节省空间、性能高，适合只需判断用户是否点赞且不需要存储具体用户 ID 的场景。Bitmap 使用偏移量定位用户，如果用户 ID 过大，容易导致偏移量浪费空间

   ```redis
   # 用户 user_1001 对内容 post_id=123 点赞
   SETBIT post:123:likes 1001 1    # 将 post:123:likes 位图中 user_1001 的位置置为 1，表示已点赞
   
   # 检查用户 user_1001 是否对 post_id=123 点赞
   GETBIT post:123:likes 1001    # 返回 1 表示已点赞，0 表示未点赞
   
   # 获取 post_id=123 的点赞总数
   BITCOUNT post:123:likes    # 返回 post:123:likes 中值为 1 的位的数量，即点赞的总数
   
   ```

   

5. **定期写入数据库**：Redis 中的点赞数据会以一定频率批量写入数据库，确保数据持久化和一致性。



## 布隆过滤器原理

**一、定义**

​	布隆过滤器是概率性数据结构，用于检查元素是否存在集合中。布隆过滤器并不存储集合中的所有元素，而是存储元素的哈希表示，因此牺牲了一些精确性：当布隆过滤报告某元素在集合中不存在时，那么它一定不存在；报告某元素存在时，允许出现“假阳性”，有时会错误地报告某个元素在集合中，而实际上它不存在，这样的权衡使得布隆过滤器非常节省空间且速度快

![Bloom Filter 的简单原理示意图](https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/bloom-filter-simple-schematic-diagram.png)

**二、原理**

**当一个元素加入布隆过滤器中的时候，会进行如下操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

**不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。**

综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在**

**缺点**

1. 存在一定的误判率：由于哈希函数的计算结果有可能冲突，布隆过滤器会出现一定程度的误判。这意味着在判断一个元素存在时，可能会出现一定的虚警情况，需要进行进一步的确认。
2. 无法删除元素：由于布隆过滤器的位数组中的位只能置为1而不能置为0，所以无法从布隆过滤器中删除已插入的元素。如果需要删除元素的功能，布隆过滤器可能不适用。
   



## 布谷鸟过滤器原理

**一、定义**

​	布谷鸟过滤器本质上是一个 **桶数组**，每个桶中保存若干数量的 **指纹**（指纹由元素的部分 Hash 值计算出来）。通常每个桶大小为4个字节，可以存储4个指纹，每个指纹占一个字节(2^8 = 256种)

二、原理

1. **指纹（Fingerprint）**：布谷鸟过滤器不直接存储元素本身，而是存储一个由元素通过哈希函数计算得到的短小指纹（通常是几个位到十几位）。

2. **两个候选位置**：与布谷鸟哈希类似，对一个元素x进行哈希时，会得到两个可能的存放位置（桶）Index1和Index2。

   - 第一个位置Index1来自对x进行哈希取模操作。
   - 第二个位置Index2则是通过Index1和x的指纹计算得到（通常为Index1 XOR hash(fingerprint(x)))的结果。

   换句话说，每个元素对应两个候选桶，元素的指纹可以放入这两个桶中的任意一个。

3. **插入过程（Insertion）**：

- 尝试将元素指纹放入第一个候选桶Index1，如果Index1有空位则直接放入。
- 如果Index1没空，就试着放入第二个候选桶Index2，如果Index2也没空，那就需要“挪动”已有元素（类似布谷鸟哈希，将现有桶中某个指纹踢走，让它去自己的另一候选桶）。
- 通过这种不断“踢”走与安置，如果最终无法在有限次数内成功插入，就表示过滤器接近饱和，需要扩容或处理冲突。

4. **查询（Lookup）**：
   给定一个元素x，计算它的两个候选桶Index1和Index2，然后查看这两个桶中是否有x对应的指纹。如果找到相同指纹则认为元素存在（存在一定的误报率，但不会漏报已插入的元素），如果两个桶都没有这个指纹，则认为元素不存在。

**优点**

1. 支持删除操作。

2. 在相同误报率下通常更节省空间：布谷鸟过滤器记录元素更加紧凑，如果期望误报率在 3% 以下，半排序桶布谷鸟过滤器每个元素所占用的空间要比布隆过滤器中单个元素占用空间要小

3. 查询速度也很快（通常只需要两次哈希）

**缺点**

1. 插入性能可能会受到影响：随着插入元素越多，空间利用率不断提高，发生冲突的可能性越大，发生冲突之后，可能会不断的触发元素的重定位，插入性能会变差，一般通过最大重试次数来限制
2. 插入重复元素次数存在上限：布隆过滤器插入重复元素没有负面影响，只是再标记相同的位，而布谷鸟过滤器插入重复元素会触发元素的重定位，因此它的重复元素插入存在上限
   

## redis保证分布式操作原子性的原理

1. **单线程模型**（核心逻辑）：保证命令的顺序执行。

2. **Lua脚本**：将复杂逻辑打包为原子操作

3. **分布式锁**：使用 `SETNX` 和 `EX` 等操作确保锁操作的原子性。

   

## Redis怎么实现的io多路复用

io多路复用参考操作系统笔记

Redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。
